var helpers = require("./helpers");
var bresenham = require("./util/bresenham");
var BulletHole = require("./particle/BulletHole");
var Flash = require("./particle/Flash");
var collisionDetection = require("./util/collisionDetection");

// instant bullet
function Bullet(data) {
    // create the bullet 5 pixels to the right and 30 pixels forward. so it aligns with the gun barrel
    var startX = data.x + Math.cos(data.direction + 1.5707963268) * 5;
    var startY = data.y + Math.sin(data.direction + 1.5707963268) * 5;
    startX = startX + Math.cos(data.direction) * 30;
    startY= startY + Math.sin(data.direction) * 30;

    var targetX = startX + Math.cos(data.direction) * 10; // shoot straight ahead from the barrel
    var targetY = startY + Math.sin(data.direction) * 10; // shoot straight ahead from the barrel

    // create muzzle flashes
    var size = Math.floor(Math.random() * 3) + 3;
    window.game.particles.push(new Flash({x: startX, y: startY, size: size, container: window.game.particles}));
    size = Math.floor(Math.random() * 2) + 2;
    var smallFlashX = startX + Math.cos(data.direction) *  (Math.floor(Math.random() * 2) + 3);
    var smallFlashY= startY + Math.sin(data.direction) *  (Math.floor(Math.random() * 2) + 3);
    window.game.particles.push(new Flash({x: smallFlashX, y: smallFlashY, size: size, container: window.game.particles}));
    size = Math.floor(Math.random() * 2) + 1;
    smallFlashX = startX + Math.cos(data.direction) *  (Math.floor(Math.random() * 2) + 8);
    smallFlashY= startY + Math.sin(data.direction) *  (Math.floor(Math.random() * 2) + 8);
    window.game.particles.push(new Flash({x: smallFlashX, y: smallFlashY, size: size, container: window.game.particles}));
    size = Math.floor(Math.random() * 2) + 2;
    smallFlashX = startX + Math.cos(data.direction) *  (Math.floor(Math.random() * 2) + 5);
    smallFlashY= startY + Math.sin(data.direction) *  (Math.floor(Math.random() * 2) + 5);
    window.game.particles.push(new Flash({x: smallFlashX, y: smallFlashY, size: size, container: window.game.particles}));
    size = Math.floor(Math.random() * 2) + 2;
    smallFlashX = startX + Math.cos(data.direction + 1.5707963268) *  (Math.floor(Math.random() * 2) + 3);
    smallFlashY = startY + Math.sin(data.direction + 1.5707963268) *  (Math.floor(Math.random() * 2) + 3);
    window.game.particles.push(new Flash({x: smallFlashX, y: smallFlashY, size: size, container: window.game.particles}));
    size = Math.floor(Math.random() * 2) + 2;
    smallFlashX = startX + Math.cos(data.direction + 1.5707963268) * - (Math.floor(Math.random() * 2) + 3);
    smallFlashY = startY + Math.sin(data.direction + 1.5707963268) * - (Math.floor(Math.random() * 2) + 3);
    window.game.particles.push(new Flash({x: smallFlashX, y: smallFlashY, size: size, container: window.game.particles}));

    // check that the bullet spawn location is inside the game
    if (!helpers.isInsideGame(startX, startY)) return;

    // check if bullet starting location is inside a tile
    var tileX = Math.floor(startX / 32);
    var tileY = Math.floor(startY / 32);
    if (helpers.getTile(tileX,tileY) === 1) return;

    var line = {
        start: {x: startX, y: startY},
        end: {x: targetX, y: targetY}
    };

    var intersect = null;

    var collision = bresenham(startX, startY, targetX, targetY); // find colliding rectangles
    if (collision) {
        switch(collision.type) {
            case "tile":
                intersect = collisionDetection.lineRectIntersect2(line, {x: collision.x * 32, y: collision.y * 32, w: 32, h: 32});
                window.game.particles.push(new BulletHole(intersect));
                break;
            case "player":
                collision.player.takeDamage(data.damage, data.direction);
                break;
        }

    }
}

Bullet.prototype.update = function(dt, index) {

};


Bullet.prototype.destroy = function(index) {
    window.game.entities.splice(index, 1);
};

Bullet.prototype.render = function(){

};

module.exports = Bullet;
